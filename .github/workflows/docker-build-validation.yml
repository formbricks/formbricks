name: Docker Build Validation

on:
  pull_request:
    branches:
      - main
  merge_group:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read

env:
  TURBO_TOKEN: ${{ secrets.TURBO_TOKEN }}
  TURBO_TEAM: ${{ vars.TURBO_TEAM }}

jobs:
  validate-docker-build:
    name: Validate Docker Build
    runs-on: ubuntu-latest

    # Add PostgreSQL service container
    services:
      postgres:
        image: pgvector/pgvector:pg17
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: formbricks
        ports:
          - 5432:5432
        # Health check to ensure PostgreSQL is ready before using it
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4.2.2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker Image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./apps/web/Dockerfile
          push: false
          load: true
          tags: formbricks-test:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          secrets: |
            database_url=${{ secrets.DUMMY_DATABASE_URL }}
            encryption_key=${{ secrets.DUMMY_ENCRYPTION_KEY }}

      - name: Verify PostgreSQL Connection
        run: |
          echo "Verifying PostgreSQL connection..."
          # Install PostgreSQL client to test connection
          sudo apt-get update && sudo apt-get install -y postgresql-client

          # Test connection using psql with timeout
          echo "Testing PostgreSQL connection with 30 second timeout..."
          timeout 30 bash -c 'until PGPASSWORD=test psql -h localhost -U test -d formbricks -c "\dt" >/dev/null 2>&1; do
            echo "Waiting for PostgreSQL to be ready..."
            sleep 2
          done'
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ PostgreSQL connection successful"
            PGPASSWORD=test psql -h localhost -U test -d formbricks -c "SELECT version();"
          else
            echo "‚ùå PostgreSQL connection failed after 30 seconds"
          fi

          # Show network configuration
          echo "Network configuration:"
          ip addr show
          netstat -tulpn | grep 5432 || echo "No process listening on port 5432"

      - name: Test Docker Image with Health Check
        shell: bash
        run: |
          echo "üß™ Testing if the Docker image starts correctly..."

          # Add extra docker run args to support host.docker.internal on Linux
          DOCKER_RUN_ARGS="--add-host=host.docker.internal:host-gateway"

          # Start the container with host.docker.internal pointing to the host
          # Add environment variables to skip migrations for testing
          docker run --name formbricks-test \
            $DOCKER_RUN_ARGS \
            -p 3000:3000 \
            -e DATABASE_URL="postgresql://test:test@host.docker.internal:5432/formbricks" \
            -e ENCRYPTION_KEY="${{ secrets.DUMMY_ENCRYPTION_KEY }}" \
            -d formbricks-test:${{ github.sha }}

          # Give it time to start up but check container status periodically
          echo "Waiting for application to start (checking every 10 seconds for up to 2 minutes)..."
          CONTAINER_WAIT_COUNT=0
          while [ $CONTAINER_WAIT_COUNT -lt 12 ]; do
            sleep 10
            CONTAINER_WAIT_COUNT=$((CONTAINER_WAIT_COUNT + 1))
            
            # Check if container is still running
            if [ "$(docker inspect -f '{{.State.Running}}' formbricks-test 2>/dev/null)" != "true" ]; then
              echo "‚ùå Container stopped running after $((CONTAINER_WAIT_COUNT * 10)) seconds!"
              echo "üìã Container logs:"
              docker logs formbricks-test
              exit 1
            fi
            
            echo "Container still running after $((CONTAINER_WAIT_COUNT * 10)) seconds..."
            
            # Show recent container logs for debugging
            echo "üìã Recent container logs:"
            docker logs --tail 10 formbricks-test
          done

          echo "‚úÖ Container has been running for 2 minutes!"

          # Try connecting to PostgreSQL from inside the container (with correct package manager)
          echo "Testing PostgreSQL connection from inside container..."
          docker exec formbricks-test sh -c '
            echo "Installing postgresql-client using apk..."
            apk add --no-cache postgresql-client
            echo "Testing connection..."
            timeout 10 sh -c "PGPASSWORD=test psql -h host.docker.internal -U test -d formbricks -c \"SELECT 1;\"" || echo "‚ùå Failed to connect to PostgreSQL from container"
          '

          # Try to access the health endpoint
          echo "üè• Testing /health endpoint..."
          MAX_RETRIES=8
          RETRY_COUNT=0
          HEALTH_CHECK_SUCCESS=false

          set +e  # Disable exit on error to allow for retries

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check attempt $RETRY_COUNT of $MAX_RETRIES..."
            
            # Show container status and logs before each attempt
            CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' formbricks-test 2>/dev/null || echo "unknown")
            echo "Container status: $CONTAINER_STATUS"
            
            if [ "$CONTAINER_STATUS" != "running" ]; then
              echo "‚ùå Container is not running (status: $CONTAINER_STATUS)"
              echo "üìã Container logs:"
              docker logs formbricks-test
              break
            fi
            
            # Check if anything is listening on port 3000 inside the container
            echo "Checking if port 3000 is open inside container..."
            docker exec formbricks-test sh -c 'netstat -tlnp 2>/dev/null | grep :3000 || echo "Nothing listening on port 3000"'
            
            # Check if Next.js server process is running
            echo "Checking for Next.js server process..."
            docker exec formbricks-test sh -c 'ps aux | grep "node.*server.js" | grep -v grep || echo "Next.js server process not found"'
            
            # Get detailed curl output for debugging
            HTTP_OUTPUT=$(curl -v -s -m 10 http://localhost:3000/health 2>&1)
            CURL_EXIT_CODE=$?
            
            echo "Curl exit code: $CURL_EXIT_CODE"
            
            if [ $CURL_EXIT_CODE -eq 0 ]; then
              STATUS_CODE=$(echo "$HTTP_OUTPUT" | grep -oP "HTTP/\d(\.\d)? \K\d+" | head -1)
              echo "Status code detected: $STATUS_CODE"
              
              if [ "$STATUS_CODE" = "200" ]; then
                echo "‚úÖ Health check successful!"
                HEALTH_CHECK_SUCCESS=true
                break
              else
                echo "‚ùå Health check returned non-200 status code: $STATUS_CODE"
                echo "Response: $HTTP_OUTPUT"
              fi
            else
              echo "‚ùå Curl command failed with exit code: $CURL_EXIT_CODE"
              echo "Error details: $HTTP_OUTPUT"
            fi
            
            # Show recent container logs for debugging
            echo "üìã Recent container logs:"
            docker logs --tail 15 formbricks-test
            
            echo "Waiting 20 seconds before next attempt..."
            sleep 20
          done

          # Show full container logs for debugging
          echo "üìã Full container logs:"
          docker logs formbricks-test

          # Clean up the container
          echo "üßπ Cleaning up..."
          docker rm -f formbricks-test

          # Exit with failure if health check did not succeed
          if [ "$HEALTH_CHECK_SUCCESS" != "true" ]; then
            echo "‚ùå Health check failed after $MAX_RETRIES attempts"
            exit 1
          fi

          echo "‚ú® Docker validation complete - all checks passed!"
