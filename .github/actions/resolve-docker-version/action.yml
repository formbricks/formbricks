name: Resolve Docker Version
description: |
  Resolves and validates Docker-compatible SemVer versions for container builds with comprehensive security.

  Security Features:
  - Command injection protection
  - Input sanitization and validation
  - Docker tag character restrictions
  - Length limits and boundary checks
  - Safe branch name handling

  Supports multiple modes: release, manual override, branch auto-detection, and experimental timestamped versions.

inputs:
  event_name:
    description: "GitHub event name (workflow_call or workflow_dispatch)"
    required: true
  version_override:
    description: "Explicit version override (SemVer only, e.g., 1.2.3-beta)"
    required: false
  workflow_call_tag:
    description: "Version from workflow_call (required for releases)"
    required: false
  current_branch:
    description: "Current branch name for auto-detection"
    required: true
  experimental_mode:
    description: "Enable experimental mode with timestamp-based versions"
    required: false
    default: "false"
  ref_type:
    description: "GitHub ref type (branch or tag) for experimental mode"
    required: false

outputs:
  version:
    description: "Resolved Docker-compatible SemVer version"
    value: ${{ steps.resolve.outputs.version }}
  source:
    description: "Source of version (release|override|branch)"
    value: ${{ steps.resolve.outputs.source }}
  normalized:
    description: "Whether the version was normalized (true/false)"
    value: ${{ steps.resolve.outputs.normalized }}

runs:
  using: "composite"
  steps:
    - name: Resolve and validate Docker version
      id: resolve
      shell: bash
      env:
        EVENT_NAME: ${{ inputs.event_name }}
        VERSION_OVERRIDE: ${{ inputs.version_override }}
        WORKFLOW_CALL_TAG: ${{ inputs.workflow_call_tag }}
        CURRENT_BRANCH: ${{ inputs.current_branch }}
        EXPERIMENTAL_MODE: ${{ inputs.experimental_mode }}
        REF_TYPE: ${{ inputs.ref_type }}
      run: |
        set -euo pipefail

        # Function to validate SemVer format (Docker-compatible, no '+' build metadata)
        validate_semver() {
          local version="$1"
          local context="$2"
          
          if [[ ! "$version" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?$ ]]; then
            echo "ERROR: Invalid $context format. Must be semver without build metadata (e.g., 1.2.3, 1.2.3-alpha)"
            echo "Provided: $version"
            echo "Note: Docker tags cannot contain '+' characters. Use prerelease identifiers instead."
            exit 1
          fi
        }

        # Function to generate branch-based version
        generate_branch_version() {
          local branch="$1"
          local use_timestamp="${2:-true}"
          local timestamp
          
          if [[ "$use_timestamp" == "true" ]]; then
            timestamp=$(date +%s)
          else
            timestamp=""
          fi
          
          # Sanitize branch name for Docker compatibility
          local sanitized_branch=$(echo "$branch" | sed 's/[^a-zA-Z0-9.-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
          
          # Additional safety: truncate if too long (reserve space for prefix and timestamp)
          if (( ${#sanitized_branch} > 80 )); then
            sanitized_branch="${sanitized_branch:0:80}"
            echo "INFO: Branch name truncated for Docker compatibility" >&2
          fi
          local version
          
          if [[ "$branch" == "main" ]]; then
            if [[ -n "$timestamp" ]]; then
              version="0.0.0-dev-$timestamp"
              echo "INFO: Main branch detected - development version: $version" >&2
            else
              version="0.0.0-dev"
              echo "INFO: Main branch detected - development version: $version" >&2
            fi
          elif [[ "$branch" =~ ^(feature|feat)/ ]]; then
            if [[ -n "$timestamp" ]]; then
              version="0.0.0-alpha-$sanitized_branch-$timestamp"
              echo "INFO: Feature branch detected - alpha version: $version" >&2
            else
              version="0.0.0-alpha-$sanitized_branch"
              echo "INFO: Feature branch detected - alpha version: $version" >&2
            fi
          elif [[ "$branch" =~ ^(hotfix|fix)/ ]]; then
            if [[ -n "$timestamp" ]]; then
              version="0.0.0-hotfix-$sanitized_branch-$timestamp"
              echo "INFO: Hotfix branch detected - hotfix version: $version" >&2
            else
              version="0.0.0-hotfix-$sanitized_branch"
              echo "INFO: Hotfix branch detected - hotfix version: $version" >&2
            fi
          elif [[ "$branch" =~ ^(release|rel)/ ]]; then
            if [[ -n "$timestamp" ]]; then
              version="0.0.0-rc-$sanitized_branch-$timestamp"
              echo "INFO: Release branch detected - release candidate version: $version" >&2
            else
              version="0.0.0-rc-$sanitized_branch"
              echo "INFO: Release branch detected - release candidate version: $version" >&2
            fi
          else
            if [[ -n "$timestamp" ]]; then
              version="0.0.0-alpha-$sanitized_branch-$timestamp"
              echo "INFO: Generic branch detected - experimental version: $version" >&2
            else
              version="0.0.0-alpha-$sanitized_branch"
              echo "INFO: Generic branch detected - experimental version: $version" >&2
            fi
          fi
          
          echo "$version"
        }

        # Function for experimental version generation (with timestamps)
        generate_experimental_version() {
          local ref_name="$1"
          local ref_type="$2"
          local timestamp=$(date +%s)
          
          if [[ "$ref_type" == "tag" ]]; then
            # If running from a tag, use the tag name + timestamp
            if [[ "$ref_name" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+.*$ ]]; then
              # Tag looks like a SemVer, use it directly (remove 'v' prefix if present)
              local base_version=$(echo "$ref_name" | sed 's/^v//')
              echo "${base_version}-${timestamp}"
              echo "INFO: SemVer tag detected - timestamped version: ${base_version}-${timestamp}" >&2
            else
              # Tag is not SemVer, treat as prerelease
              local sanitized_tag=$(echo "$ref_name" | sed 's/[^a-zA-Z0-9.-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
              echo "0.0.0-${sanitized_tag}-${timestamp}"
              echo "INFO: Non-SemVer tag detected - experimental version: 0.0.0-${sanitized_tag}-${timestamp}" >&2
            fi
          else
            # Running from branch, use branch name as prerelease + timestamp
            local sanitized_branch=$(echo "$ref_name" | sed 's/[^a-zA-Z0-9.-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
            echo "0.0.0-${sanitized_branch}-${timestamp}"
            echo "INFO: Branch detected - experimental version: 0.0.0-${sanitized_branch}-${timestamp}" >&2
          fi
        }

        # Input validation and sanitization
        if [[ -z "$EVENT_NAME" ]]; then
          echo "ERROR: event_name input is required"
          exit 1
        fi

        if [[ "$EVENT_NAME" != "workflow_call" && "$EVENT_NAME" != "workflow_dispatch" ]]; then
          echo "ERROR: event_name must be 'workflow_call' or 'workflow_dispatch'"
          echo "Provided: $EVENT_NAME"
          exit 1
        fi

        if [[ -z "$CURRENT_BRANCH" ]]; then
          echo "ERROR: current_branch input is required"
          exit 1
        fi

        # Security: Validate inputs to prevent command injection
        # Branch names should not contain dangerous characters
        if [[ "$CURRENT_BRANCH" =~ [';|&`$(){}\\]]; then
          echo "ERROR: Branch name contains potentially dangerous characters: $CURRENT_BRANCH"
          echo "Branch names should only contain letters, numbers, hyphens, underscores, dots, and forward slashes"
          exit 1
        fi

        # Validate workflow_call_tag if provided
        if [[ -n "$WORKFLOW_CALL_TAG" ]] && [[ "$WORKFLOW_CALL_TAG" =~ [';|&`$(){}\\]]; then
          echo "ERROR: Workflow call tag contains potentially dangerous characters: $WORKFLOW_CALL_TAG"
          exit 1
        fi

        # Validate version_override if provided
        if [[ -n "$VERSION_OVERRIDE" ]] && [[ "$VERSION_OVERRIDE" =~ [';|&`$(){}\\]]; then
          echo "ERROR: Version override contains potentially dangerous characters: $VERSION_OVERRIDE"
          exit 1
        fi

        # Main resolution logic
        NORMALIZED="false"

        if [[ "$EVENT_NAME" == "workflow_call" ]]; then
          # Release workflow - use provided tag
          if [[ -z "$WORKFLOW_CALL_TAG" ]]; then
            echo "ERROR: workflow_call_tag input is required for workflow_call events"
            exit 1
          fi
          
          validate_semver "$WORKFLOW_CALL_TAG" "release tag"
          
          # Normalize to lowercase for Docker/ECR compatibility
          RESOLVED_VERSION="${WORKFLOW_CALL_TAG,,}"
          if [[ "$WORKFLOW_CALL_TAG" != "$RESOLVED_VERSION" ]]; then
            NORMALIZED="true"
            echo "INFO: Original tag contained uppercase characters, normalized: $WORKFLOW_CALL_TAG -> $RESOLVED_VERSION"
          fi
          
          SOURCE="release"
          echo "INFO: Using release version: $RESOLVED_VERSION"
          
        else
          # Manual workflow_dispatch
          if [[ -n "$VERSION_OVERRIDE" ]]; then
            # User provided explicit override
            validate_semver "$VERSION_OVERRIDE" "version override"
            RESOLVED_VERSION="$VERSION_OVERRIDE"
            SOURCE="override"
            echo "INFO: Using explicit version override: $RESOLVED_VERSION"
          else
            # Check for experimental mode
            if [[ "$EXPERIMENTAL_MODE" == "true" ]]; then
              # Use experimental version generation (always with timestamps)
              echo "INFO: Experimental mode: generating timestamped version"
              RESOLVED_VERSION=$(generate_experimental_version "$CURRENT_BRANCH" "${REF_TYPE:-branch}")
              SOURCE="experimental"
            else
              # Auto-detect from branch (standard mode)
              echo "INFO: Auto-detecting version from branch: ${CURRENT_BRANCH}"
              RESOLVED_VERSION=$(generate_branch_version "$CURRENT_BRANCH")
              SOURCE="branch"
            fi
            echo "Generated version: $RESOLVED_VERSION"
          fi
        fi

        # Final validation - ensure result is valid Docker tag
        if [[ -z "$RESOLVED_VERSION" ]]; then
          echo "ERROR: Failed to resolve version"
          exit 1
        fi

        if (( ${#RESOLVED_VERSION} > 128 )); then
          echo "ERROR: Version must be at most 128 characters (Docker limitation)"
          echo "Generated version: $RESOLVED_VERSION (${#RESOLVED_VERSION} chars)"
          exit 1
        fi

        if [[ ! "$RESOLVED_VERSION" =~ ^[a-z0-9._-]+$ ]]; then
          echo "ERROR: Version contains invalid characters for Docker tags"
          echo "Version: $RESOLVED_VERSION"
          exit 1
        fi

        if [[ "$RESOLVED_VERSION" =~ ^[.-] || "$RESOLVED_VERSION" =~ [.-]$ ]]; then
          echo "ERROR: Version must not start or end with '.' or '-'"
          echo "Version: $RESOLVED_VERSION"
          exit 1
        fi

        # Output results
        echo "SUCCESS: Resolved Docker version: $RESOLVED_VERSION (source: $SOURCE)"
        echo "version=$RESOLVED_VERSION" >> $GITHUB_OUTPUT
        echo "source=$SOURCE" >> $GITHUB_OUTPUT
        echo "normalized=$NORMALIZED" >> $GITHUB_OUTPUT
