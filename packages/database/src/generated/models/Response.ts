/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Response` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client";
import type * as $Enums from "../enums";
import type * as Prisma from "../internal/prismaNamespace";
import type * as PJTG from "../pjtg";

/**
 * Model Response
 * Stores a user's response to a survey, including their answers and metadata.
 * Each response is linked to a specific survey and optionally to a contact.
 *
 * @property id - Unique identifier for the response
 * @property finished - Whether the survey was completed
 * @property survey - The associated survey
 * @property contact - The optional contact who provided the response
 * @property data - JSON object containing the actual response data
 * @property variables - Custom variables used in the response
 * @property ttc - Time to completion metrics
 * @property meta - Additional metadata about the response
 */
export type ResponseModel = runtime.Types.Result.DefaultSelection<Prisma.$ResponsePayload>;

export type AggregateResponse = {
  _count: ResponseCountAggregateOutputType | null;
  _min: ResponseMinAggregateOutputType | null;
  _max: ResponseMaxAggregateOutputType | null;
};

export type ResponseMinAggregateOutputType = {
  id: string | null;
  createdAt: Date | null;
  updatedAt: Date | null;
  finished: boolean | null;
  surveyId: string | null;
  contactId: string | null;
  endingId: string | null;
  singleUseId: string | null;
  language: string | null;
  displayId: string | null;
};

export type ResponseMaxAggregateOutputType = {
  id: string | null;
  createdAt: Date | null;
  updatedAt: Date | null;
  finished: boolean | null;
  surveyId: string | null;
  contactId: string | null;
  endingId: string | null;
  singleUseId: string | null;
  language: string | null;
  displayId: string | null;
};

export type ResponseCountAggregateOutputType = {
  id: number;
  createdAt: number;
  updatedAt: number;
  finished: number;
  surveyId: number;
  contactId: number;
  endingId: number;
  data: number;
  variables: number;
  ttc: number;
  meta: number;
  contactAttributes: number;
  singleUseId: number;
  language: number;
  displayId: number;
  _all: number;
};

export type ResponseMinAggregateInputType = {
  id?: true;
  createdAt?: true;
  updatedAt?: true;
  finished?: true;
  surveyId?: true;
  contactId?: true;
  endingId?: true;
  singleUseId?: true;
  language?: true;
  displayId?: true;
};

export type ResponseMaxAggregateInputType = {
  id?: true;
  createdAt?: true;
  updatedAt?: true;
  finished?: true;
  surveyId?: true;
  contactId?: true;
  endingId?: true;
  singleUseId?: true;
  language?: true;
  displayId?: true;
};

export type ResponseCountAggregateInputType = {
  id?: true;
  createdAt?: true;
  updatedAt?: true;
  finished?: true;
  surveyId?: true;
  contactId?: true;
  endingId?: true;
  data?: true;
  variables?: true;
  ttc?: true;
  meta?: true;
  contactAttributes?: true;
  singleUseId?: true;
  language?: true;
  displayId?: true;
  _all?: true;
};

export type ResponseAggregateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Response to aggregate.
   */
  where?: Prisma.ResponseWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Responses to fetch.
   */
  orderBy?: Prisma.ResponseOrderByWithRelationInput | Prisma.ResponseOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the start position
   */
  cursor?: Prisma.ResponseWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Responses from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Responses.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Count returned Responses
   **/
  _count?: true | ResponseCountAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the minimum value
   **/
  _min?: ResponseMinAggregateInputType;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   *
   * Select which fields to find the maximum value
   **/
  _max?: ResponseMaxAggregateInputType;
};

export type GetResponseAggregateType<T extends ResponseAggregateArgs> = {
  [P in keyof T & keyof AggregateResponse]: P extends "_count" | "count"
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateResponse[P]>
    : Prisma.GetScalarType<T[P], AggregateResponse[P]>;
};

export type ResponseGroupByArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ResponseWhereInput;
  orderBy?: Prisma.ResponseOrderByWithAggregationInput | Prisma.ResponseOrderByWithAggregationInput[];
  by: Prisma.ResponseScalarFieldEnum[] | Prisma.ResponseScalarFieldEnum;
  having?: Prisma.ResponseScalarWhereWithAggregatesInput;
  take?: number;
  skip?: number;
  _count?: ResponseCountAggregateInputType | true;
  _min?: ResponseMinAggregateInputType;
  _max?: ResponseMaxAggregateInputType;
};

export type ResponseGroupByOutputType = {
  id: string;
  createdAt: Date;
  updatedAt: Date;
  finished: boolean;
  surveyId: string;
  contactId: string | null;
  endingId: string | null;
  data: PrismaJson.ResponseData;
  variables: PrismaJson.ResponseVariables;
  ttc: PrismaJson.ResponseTtc;
  meta: PrismaJson.ResponseMeta;
  contactAttributes: PrismaJson.ResponseContactAttributes | null;
  singleUseId: string | null;
  language: string | null;
  displayId: string | null;
  _count: ResponseCountAggregateOutputType | null;
  _min: ResponseMinAggregateOutputType | null;
  _max: ResponseMaxAggregateOutputType | null;
};

type GetResponseGroupByPayload<T extends ResponseGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<ResponseGroupByOutputType, T["by"]> & {
      [P in keyof T & keyof ResponseGroupByOutputType]: P extends "_count"
        ? T[P] extends boolean
          ? number
          : Prisma.GetScalarType<T[P], ResponseGroupByOutputType[P]>
        : Prisma.GetScalarType<T[P], ResponseGroupByOutputType[P]>;
    }
  >
>;

export type ResponseWhereInput = {
  AND?: Prisma.ResponseWhereInput | Prisma.ResponseWhereInput[];
  OR?: Prisma.ResponseWhereInput[];
  NOT?: Prisma.ResponseWhereInput | Prisma.ResponseWhereInput[];
  id?: Prisma.StringFilter<"Response"> | string;
  createdAt?: Prisma.DateTimeFilter<"Response"> | Date | string;
  updatedAt?: Prisma.DateTimeFilter<"Response"> | Date | string;
  finished?: Prisma.BoolFilter<"Response"> | boolean;
  surveyId?: Prisma.StringFilter<"Response"> | string;
  contactId?: Prisma.StringNullableFilter<"Response"> | string | null;
  endingId?: Prisma.StringNullableFilter<"Response"> | string | null;
  data?: Prisma.JsonFilter<"Response">;
  variables?: Prisma.JsonFilter<"Response">;
  ttc?: Prisma.JsonFilter<"Response">;
  meta?: Prisma.JsonFilter<"Response">;
  contactAttributes?: Prisma.JsonNullableFilter<"Response">;
  singleUseId?: Prisma.StringNullableFilter<"Response"> | string | null;
  language?: Prisma.StringNullableFilter<"Response"> | string | null;
  displayId?: Prisma.StringNullableFilter<"Response"> | string | null;
  survey?: Prisma.XOR<Prisma.SurveyScalarRelationFilter, Prisma.SurveyWhereInput>;
  contact?: Prisma.XOR<Prisma.ContactNullableScalarRelationFilter, Prisma.ContactWhereInput> | null;
  tags?: Prisma.TagsOnResponsesListRelationFilter;
  quotaLinks?: Prisma.ResponseQuotaLinkListRelationFilter;
  display?: Prisma.XOR<Prisma.DisplayNullableScalarRelationFilter, Prisma.DisplayWhereInput> | null;
};

export type ResponseOrderByWithRelationInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  finished?: Prisma.SortOrder;
  surveyId?: Prisma.SortOrder;
  contactId?: Prisma.SortOrderInput | Prisma.SortOrder;
  endingId?: Prisma.SortOrderInput | Prisma.SortOrder;
  data?: Prisma.SortOrder;
  variables?: Prisma.SortOrder;
  ttc?: Prisma.SortOrder;
  meta?: Prisma.SortOrder;
  contactAttributes?: Prisma.SortOrderInput | Prisma.SortOrder;
  singleUseId?: Prisma.SortOrderInput | Prisma.SortOrder;
  language?: Prisma.SortOrderInput | Prisma.SortOrder;
  displayId?: Prisma.SortOrderInput | Prisma.SortOrder;
  survey?: Prisma.SurveyOrderByWithRelationInput;
  contact?: Prisma.ContactOrderByWithRelationInput;
  tags?: Prisma.TagsOnResponsesOrderByRelationAggregateInput;
  quotaLinks?: Prisma.ResponseQuotaLinkOrderByRelationAggregateInput;
  display?: Prisma.DisplayOrderByWithRelationInput;
};

export type ResponseWhereUniqueInput = Prisma.AtLeast<
  {
    id?: string;
    displayId?: string;
    surveyId_singleUseId?: Prisma.ResponseSurveyIdSingleUseIdCompoundUniqueInput;
    AND?: Prisma.ResponseWhereInput | Prisma.ResponseWhereInput[];
    OR?: Prisma.ResponseWhereInput[];
    NOT?: Prisma.ResponseWhereInput | Prisma.ResponseWhereInput[];
    createdAt?: Prisma.DateTimeFilter<"Response"> | Date | string;
    updatedAt?: Prisma.DateTimeFilter<"Response"> | Date | string;
    finished?: Prisma.BoolFilter<"Response"> | boolean;
    surveyId?: Prisma.StringFilter<"Response"> | string;
    contactId?: Prisma.StringNullableFilter<"Response"> | string | null;
    endingId?: Prisma.StringNullableFilter<"Response"> | string | null;
    data?: Prisma.JsonFilter<"Response">;
    variables?: Prisma.JsonFilter<"Response">;
    ttc?: Prisma.JsonFilter<"Response">;
    meta?: Prisma.JsonFilter<"Response">;
    contactAttributes?: Prisma.JsonNullableFilter<"Response">;
    singleUseId?: Prisma.StringNullableFilter<"Response"> | string | null;
    language?: Prisma.StringNullableFilter<"Response"> | string | null;
    survey?: Prisma.XOR<Prisma.SurveyScalarRelationFilter, Prisma.SurveyWhereInput>;
    contact?: Prisma.XOR<Prisma.ContactNullableScalarRelationFilter, Prisma.ContactWhereInput> | null;
    tags?: Prisma.TagsOnResponsesListRelationFilter;
    quotaLinks?: Prisma.ResponseQuotaLinkListRelationFilter;
    display?: Prisma.XOR<Prisma.DisplayNullableScalarRelationFilter, Prisma.DisplayWhereInput> | null;
  },
  "id" | "displayId" | "surveyId_singleUseId"
>;

export type ResponseOrderByWithAggregationInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  finished?: Prisma.SortOrder;
  surveyId?: Prisma.SortOrder;
  contactId?: Prisma.SortOrderInput | Prisma.SortOrder;
  endingId?: Prisma.SortOrderInput | Prisma.SortOrder;
  data?: Prisma.SortOrder;
  variables?: Prisma.SortOrder;
  ttc?: Prisma.SortOrder;
  meta?: Prisma.SortOrder;
  contactAttributes?: Prisma.SortOrderInput | Prisma.SortOrder;
  singleUseId?: Prisma.SortOrderInput | Prisma.SortOrder;
  language?: Prisma.SortOrderInput | Prisma.SortOrder;
  displayId?: Prisma.SortOrderInput | Prisma.SortOrder;
  _count?: Prisma.ResponseCountOrderByAggregateInput;
  _max?: Prisma.ResponseMaxOrderByAggregateInput;
  _min?: Prisma.ResponseMinOrderByAggregateInput;
};

export type ResponseScalarWhereWithAggregatesInput = {
  AND?: Prisma.ResponseScalarWhereWithAggregatesInput | Prisma.ResponseScalarWhereWithAggregatesInput[];
  OR?: Prisma.ResponseScalarWhereWithAggregatesInput[];
  NOT?: Prisma.ResponseScalarWhereWithAggregatesInput | Prisma.ResponseScalarWhereWithAggregatesInput[];
  id?: Prisma.StringWithAggregatesFilter<"Response"> | string;
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Response"> | Date | string;
  updatedAt?: Prisma.DateTimeWithAggregatesFilter<"Response"> | Date | string;
  finished?: Prisma.BoolWithAggregatesFilter<"Response"> | boolean;
  surveyId?: Prisma.StringWithAggregatesFilter<"Response"> | string;
  contactId?: Prisma.StringNullableWithAggregatesFilter<"Response"> | string | null;
  endingId?: Prisma.StringNullableWithAggregatesFilter<"Response"> | string | null;
  data?: Prisma.JsonWithAggregatesFilter<"Response">;
  variables?: Prisma.JsonWithAggregatesFilter<"Response">;
  ttc?: Prisma.JsonWithAggregatesFilter<"Response">;
  meta?: Prisma.JsonWithAggregatesFilter<"Response">;
  contactAttributes?: Prisma.JsonNullableWithAggregatesFilter<"Response">;
  singleUseId?: Prisma.StringNullableWithAggregatesFilter<"Response"> | string | null;
  language?: Prisma.StringNullableWithAggregatesFilter<"Response"> | string | null;
  displayId?: Prisma.StringNullableWithAggregatesFilter<"Response"> | string | null;
};

export type ResponseCreateInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  survey: Prisma.SurveyCreateNestedOneWithoutResponsesInput;
  contact?: Prisma.ContactCreateNestedOneWithoutResponsesInput;
  tags?: Prisma.TagsOnResponsesCreateNestedManyWithoutResponseInput;
  quotaLinks?: Prisma.ResponseQuotaLinkCreateNestedManyWithoutResponseInput;
  display?: Prisma.DisplayCreateNestedOneWithoutResponseInput;
};

export type ResponseUncheckedCreateInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  surveyId: string;
  contactId?: string | null;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  displayId?: string | null;
  tags?: Prisma.TagsOnResponsesUncheckedCreateNestedManyWithoutResponseInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedCreateNestedManyWithoutResponseInput;
};

export type ResponseUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  survey?: Prisma.SurveyUpdateOneRequiredWithoutResponsesNestedInput;
  contact?: Prisma.ContactUpdateOneWithoutResponsesNestedInput;
  tags?: Prisma.TagsOnResponsesUpdateManyWithoutResponseNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUpdateManyWithoutResponseNestedInput;
  display?: Prisma.DisplayUpdateOneWithoutResponseNestedInput;
};

export type ResponseUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  surveyId?: Prisma.StringFieldUpdateOperationsInput | string;
  contactId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  displayId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  tags?: Prisma.TagsOnResponsesUncheckedUpdateManyWithoutResponseNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedUpdateManyWithoutResponseNestedInput;
};

export type ResponseCreateManyInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  surveyId: string;
  contactId?: string | null;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  displayId?: string | null;
};

export type ResponseUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

export type ResponseUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  surveyId?: Prisma.StringFieldUpdateOperationsInput | string;
  contactId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  displayId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

export type ResponseListRelationFilter = {
  every?: Prisma.ResponseWhereInput;
  some?: Prisma.ResponseWhereInput;
  none?: Prisma.ResponseWhereInput;
};

export type ResponseOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder;
};

export type ResponseSurveyIdSingleUseIdCompoundUniqueInput = {
  surveyId: string;
  singleUseId: string;
};

export type ResponseCountOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  finished?: Prisma.SortOrder;
  surveyId?: Prisma.SortOrder;
  contactId?: Prisma.SortOrder;
  endingId?: Prisma.SortOrder;
  data?: Prisma.SortOrder;
  variables?: Prisma.SortOrder;
  ttc?: Prisma.SortOrder;
  meta?: Prisma.SortOrder;
  contactAttributes?: Prisma.SortOrder;
  singleUseId?: Prisma.SortOrder;
  language?: Prisma.SortOrder;
  displayId?: Prisma.SortOrder;
};

export type ResponseMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  finished?: Prisma.SortOrder;
  surveyId?: Prisma.SortOrder;
  contactId?: Prisma.SortOrder;
  endingId?: Prisma.SortOrder;
  singleUseId?: Prisma.SortOrder;
  language?: Prisma.SortOrder;
  displayId?: Prisma.SortOrder;
};

export type ResponseMinOrderByAggregateInput = {
  id?: Prisma.SortOrder;
  createdAt?: Prisma.SortOrder;
  updatedAt?: Prisma.SortOrder;
  finished?: Prisma.SortOrder;
  surveyId?: Prisma.SortOrder;
  contactId?: Prisma.SortOrder;
  endingId?: Prisma.SortOrder;
  singleUseId?: Prisma.SortOrder;
  language?: Prisma.SortOrder;
  displayId?: Prisma.SortOrder;
};

export type ResponseScalarRelationFilter = {
  is?: Prisma.ResponseWhereInput;
  isNot?: Prisma.ResponseWhereInput;
};

export type ResponseNullableScalarRelationFilter = {
  is?: Prisma.ResponseWhereInput | null;
  isNot?: Prisma.ResponseWhereInput | null;
};

export type ResponseCreateNestedManyWithoutContactInput = {
  create?:
    | Prisma.XOR<Prisma.ResponseCreateWithoutContactInput, Prisma.ResponseUncheckedCreateWithoutContactInput>
    | Prisma.ResponseCreateWithoutContactInput[]
    | Prisma.ResponseUncheckedCreateWithoutContactInput[];
  connectOrCreate?:
    | Prisma.ResponseCreateOrConnectWithoutContactInput
    | Prisma.ResponseCreateOrConnectWithoutContactInput[];
  createMany?: Prisma.ResponseCreateManyContactInputEnvelope;
  connect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
};

export type ResponseUncheckedCreateNestedManyWithoutContactInput = {
  create?:
    | Prisma.XOR<Prisma.ResponseCreateWithoutContactInput, Prisma.ResponseUncheckedCreateWithoutContactInput>
    | Prisma.ResponseCreateWithoutContactInput[]
    | Prisma.ResponseUncheckedCreateWithoutContactInput[];
  connectOrCreate?:
    | Prisma.ResponseCreateOrConnectWithoutContactInput
    | Prisma.ResponseCreateOrConnectWithoutContactInput[];
  createMany?: Prisma.ResponseCreateManyContactInputEnvelope;
  connect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
};

export type ResponseUpdateManyWithoutContactNestedInput = {
  create?:
    | Prisma.XOR<Prisma.ResponseCreateWithoutContactInput, Prisma.ResponseUncheckedCreateWithoutContactInput>
    | Prisma.ResponseCreateWithoutContactInput[]
    | Prisma.ResponseUncheckedCreateWithoutContactInput[];
  connectOrCreate?:
    | Prisma.ResponseCreateOrConnectWithoutContactInput
    | Prisma.ResponseCreateOrConnectWithoutContactInput[];
  upsert?:
    | Prisma.ResponseUpsertWithWhereUniqueWithoutContactInput
    | Prisma.ResponseUpsertWithWhereUniqueWithoutContactInput[];
  createMany?: Prisma.ResponseCreateManyContactInputEnvelope;
  set?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  disconnect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  delete?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  connect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  update?:
    | Prisma.ResponseUpdateWithWhereUniqueWithoutContactInput
    | Prisma.ResponseUpdateWithWhereUniqueWithoutContactInput[];
  updateMany?:
    | Prisma.ResponseUpdateManyWithWhereWithoutContactInput
    | Prisma.ResponseUpdateManyWithWhereWithoutContactInput[];
  deleteMany?: Prisma.ResponseScalarWhereInput | Prisma.ResponseScalarWhereInput[];
};

export type ResponseUncheckedUpdateManyWithoutContactNestedInput = {
  create?:
    | Prisma.XOR<Prisma.ResponseCreateWithoutContactInput, Prisma.ResponseUncheckedCreateWithoutContactInput>
    | Prisma.ResponseCreateWithoutContactInput[]
    | Prisma.ResponseUncheckedCreateWithoutContactInput[];
  connectOrCreate?:
    | Prisma.ResponseCreateOrConnectWithoutContactInput
    | Prisma.ResponseCreateOrConnectWithoutContactInput[];
  upsert?:
    | Prisma.ResponseUpsertWithWhereUniqueWithoutContactInput
    | Prisma.ResponseUpsertWithWhereUniqueWithoutContactInput[];
  createMany?: Prisma.ResponseCreateManyContactInputEnvelope;
  set?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  disconnect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  delete?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  connect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  update?:
    | Prisma.ResponseUpdateWithWhereUniqueWithoutContactInput
    | Prisma.ResponseUpdateWithWhereUniqueWithoutContactInput[];
  updateMany?:
    | Prisma.ResponseUpdateManyWithWhereWithoutContactInput
    | Prisma.ResponseUpdateManyWithWhereWithoutContactInput[];
  deleteMany?: Prisma.ResponseScalarWhereInput | Prisma.ResponseScalarWhereInput[];
};

export type ResponseCreateNestedOneWithoutTagsInput = {
  create?: Prisma.XOR<Prisma.ResponseCreateWithoutTagsInput, Prisma.ResponseUncheckedCreateWithoutTagsInput>;
  connectOrCreate?: Prisma.ResponseCreateOrConnectWithoutTagsInput;
  connect?: Prisma.ResponseWhereUniqueInput;
};

export type ResponseUpdateOneRequiredWithoutTagsNestedInput = {
  create?: Prisma.XOR<Prisma.ResponseCreateWithoutTagsInput, Prisma.ResponseUncheckedCreateWithoutTagsInput>;
  connectOrCreate?: Prisma.ResponseCreateOrConnectWithoutTagsInput;
  upsert?: Prisma.ResponseUpsertWithoutTagsInput;
  connect?: Prisma.ResponseWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<Prisma.ResponseUpdateToOneWithWhereWithoutTagsInput, Prisma.ResponseUpdateWithoutTagsInput>,
    Prisma.ResponseUncheckedUpdateWithoutTagsInput
  >;
};

export type ResponseCreateNestedOneWithoutDisplayInput = {
  create?: Prisma.XOR<
    Prisma.ResponseCreateWithoutDisplayInput,
    Prisma.ResponseUncheckedCreateWithoutDisplayInput
  >;
  connectOrCreate?: Prisma.ResponseCreateOrConnectWithoutDisplayInput;
  connect?: Prisma.ResponseWhereUniqueInput;
};

export type ResponseUncheckedCreateNestedOneWithoutDisplayInput = {
  create?: Prisma.XOR<
    Prisma.ResponseCreateWithoutDisplayInput,
    Prisma.ResponseUncheckedCreateWithoutDisplayInput
  >;
  connectOrCreate?: Prisma.ResponseCreateOrConnectWithoutDisplayInput;
  connect?: Prisma.ResponseWhereUniqueInput;
};

export type ResponseUpdateOneWithoutDisplayNestedInput = {
  create?: Prisma.XOR<
    Prisma.ResponseCreateWithoutDisplayInput,
    Prisma.ResponseUncheckedCreateWithoutDisplayInput
  >;
  connectOrCreate?: Prisma.ResponseCreateOrConnectWithoutDisplayInput;
  upsert?: Prisma.ResponseUpsertWithoutDisplayInput;
  disconnect?: Prisma.ResponseWhereInput | boolean;
  delete?: Prisma.ResponseWhereInput | boolean;
  connect?: Prisma.ResponseWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ResponseUpdateToOneWithWhereWithoutDisplayInput,
      Prisma.ResponseUpdateWithoutDisplayInput
    >,
    Prisma.ResponseUncheckedUpdateWithoutDisplayInput
  >;
};

export type ResponseUncheckedUpdateOneWithoutDisplayNestedInput = {
  create?: Prisma.XOR<
    Prisma.ResponseCreateWithoutDisplayInput,
    Prisma.ResponseUncheckedCreateWithoutDisplayInput
  >;
  connectOrCreate?: Prisma.ResponseCreateOrConnectWithoutDisplayInput;
  upsert?: Prisma.ResponseUpsertWithoutDisplayInput;
  disconnect?: Prisma.ResponseWhereInput | boolean;
  delete?: Prisma.ResponseWhereInput | boolean;
  connect?: Prisma.ResponseWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ResponseUpdateToOneWithWhereWithoutDisplayInput,
      Prisma.ResponseUpdateWithoutDisplayInput
    >,
    Prisma.ResponseUncheckedUpdateWithoutDisplayInput
  >;
};

export type ResponseCreateNestedManyWithoutSurveyInput = {
  create?:
    | Prisma.XOR<Prisma.ResponseCreateWithoutSurveyInput, Prisma.ResponseUncheckedCreateWithoutSurveyInput>
    | Prisma.ResponseCreateWithoutSurveyInput[]
    | Prisma.ResponseUncheckedCreateWithoutSurveyInput[];
  connectOrCreate?:
    | Prisma.ResponseCreateOrConnectWithoutSurveyInput
    | Prisma.ResponseCreateOrConnectWithoutSurveyInput[];
  createMany?: Prisma.ResponseCreateManySurveyInputEnvelope;
  connect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
};

export type ResponseUncheckedCreateNestedManyWithoutSurveyInput = {
  create?:
    | Prisma.XOR<Prisma.ResponseCreateWithoutSurveyInput, Prisma.ResponseUncheckedCreateWithoutSurveyInput>
    | Prisma.ResponseCreateWithoutSurveyInput[]
    | Prisma.ResponseUncheckedCreateWithoutSurveyInput[];
  connectOrCreate?:
    | Prisma.ResponseCreateOrConnectWithoutSurveyInput
    | Prisma.ResponseCreateOrConnectWithoutSurveyInput[];
  createMany?: Prisma.ResponseCreateManySurveyInputEnvelope;
  connect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
};

export type ResponseUpdateManyWithoutSurveyNestedInput = {
  create?:
    | Prisma.XOR<Prisma.ResponseCreateWithoutSurveyInput, Prisma.ResponseUncheckedCreateWithoutSurveyInput>
    | Prisma.ResponseCreateWithoutSurveyInput[]
    | Prisma.ResponseUncheckedCreateWithoutSurveyInput[];
  connectOrCreate?:
    | Prisma.ResponseCreateOrConnectWithoutSurveyInput
    | Prisma.ResponseCreateOrConnectWithoutSurveyInput[];
  upsert?:
    | Prisma.ResponseUpsertWithWhereUniqueWithoutSurveyInput
    | Prisma.ResponseUpsertWithWhereUniqueWithoutSurveyInput[];
  createMany?: Prisma.ResponseCreateManySurveyInputEnvelope;
  set?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  disconnect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  delete?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  connect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  update?:
    | Prisma.ResponseUpdateWithWhereUniqueWithoutSurveyInput
    | Prisma.ResponseUpdateWithWhereUniqueWithoutSurveyInput[];
  updateMany?:
    | Prisma.ResponseUpdateManyWithWhereWithoutSurveyInput
    | Prisma.ResponseUpdateManyWithWhereWithoutSurveyInput[];
  deleteMany?: Prisma.ResponseScalarWhereInput | Prisma.ResponseScalarWhereInput[];
};

export type ResponseUncheckedUpdateManyWithoutSurveyNestedInput = {
  create?:
    | Prisma.XOR<Prisma.ResponseCreateWithoutSurveyInput, Prisma.ResponseUncheckedCreateWithoutSurveyInput>
    | Prisma.ResponseCreateWithoutSurveyInput[]
    | Prisma.ResponseUncheckedCreateWithoutSurveyInput[];
  connectOrCreate?:
    | Prisma.ResponseCreateOrConnectWithoutSurveyInput
    | Prisma.ResponseCreateOrConnectWithoutSurveyInput[];
  upsert?:
    | Prisma.ResponseUpsertWithWhereUniqueWithoutSurveyInput
    | Prisma.ResponseUpsertWithWhereUniqueWithoutSurveyInput[];
  createMany?: Prisma.ResponseCreateManySurveyInputEnvelope;
  set?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  disconnect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  delete?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  connect?: Prisma.ResponseWhereUniqueInput | Prisma.ResponseWhereUniqueInput[];
  update?:
    | Prisma.ResponseUpdateWithWhereUniqueWithoutSurveyInput
    | Prisma.ResponseUpdateWithWhereUniqueWithoutSurveyInput[];
  updateMany?:
    | Prisma.ResponseUpdateManyWithWhereWithoutSurveyInput
    | Prisma.ResponseUpdateManyWithWhereWithoutSurveyInput[];
  deleteMany?: Prisma.ResponseScalarWhereInput | Prisma.ResponseScalarWhereInput[];
};

export type ResponseCreateNestedOneWithoutQuotaLinksInput = {
  create?: Prisma.XOR<
    Prisma.ResponseCreateWithoutQuotaLinksInput,
    Prisma.ResponseUncheckedCreateWithoutQuotaLinksInput
  >;
  connectOrCreate?: Prisma.ResponseCreateOrConnectWithoutQuotaLinksInput;
  connect?: Prisma.ResponseWhereUniqueInput;
};

export type ResponseUpdateOneRequiredWithoutQuotaLinksNestedInput = {
  create?: Prisma.XOR<
    Prisma.ResponseCreateWithoutQuotaLinksInput,
    Prisma.ResponseUncheckedCreateWithoutQuotaLinksInput
  >;
  connectOrCreate?: Prisma.ResponseCreateOrConnectWithoutQuotaLinksInput;
  upsert?: Prisma.ResponseUpsertWithoutQuotaLinksInput;
  connect?: Prisma.ResponseWhereUniqueInput;
  update?: Prisma.XOR<
    Prisma.XOR<
      Prisma.ResponseUpdateToOneWithWhereWithoutQuotaLinksInput,
      Prisma.ResponseUpdateWithoutQuotaLinksInput
    >,
    Prisma.ResponseUncheckedUpdateWithoutQuotaLinksInput
  >;
};

export type ResponseCreateWithoutContactInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  survey: Prisma.SurveyCreateNestedOneWithoutResponsesInput;
  tags?: Prisma.TagsOnResponsesCreateNestedManyWithoutResponseInput;
  quotaLinks?: Prisma.ResponseQuotaLinkCreateNestedManyWithoutResponseInput;
  display?: Prisma.DisplayCreateNestedOneWithoutResponseInput;
};

export type ResponseUncheckedCreateWithoutContactInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  surveyId: string;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  displayId?: string | null;
  tags?: Prisma.TagsOnResponsesUncheckedCreateNestedManyWithoutResponseInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedCreateNestedManyWithoutResponseInput;
};

export type ResponseCreateOrConnectWithoutContactInput = {
  where: Prisma.ResponseWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ResponseCreateWithoutContactInput,
    Prisma.ResponseUncheckedCreateWithoutContactInput
  >;
};

export type ResponseCreateManyContactInputEnvelope = {
  data: Prisma.ResponseCreateManyContactInput | Prisma.ResponseCreateManyContactInput[];
  skipDuplicates?: boolean;
};

export type ResponseUpsertWithWhereUniqueWithoutContactInput = {
  where: Prisma.ResponseWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.ResponseUpdateWithoutContactInput,
    Prisma.ResponseUncheckedUpdateWithoutContactInput
  >;
  create: Prisma.XOR<
    Prisma.ResponseCreateWithoutContactInput,
    Prisma.ResponseUncheckedCreateWithoutContactInput
  >;
};

export type ResponseUpdateWithWhereUniqueWithoutContactInput = {
  where: Prisma.ResponseWhereUniqueInput;
  data: Prisma.XOR<
    Prisma.ResponseUpdateWithoutContactInput,
    Prisma.ResponseUncheckedUpdateWithoutContactInput
  >;
};

export type ResponseUpdateManyWithWhereWithoutContactInput = {
  where: Prisma.ResponseScalarWhereInput;
  data: Prisma.XOR<
    Prisma.ResponseUpdateManyMutationInput,
    Prisma.ResponseUncheckedUpdateManyWithoutContactInput
  >;
};

export type ResponseScalarWhereInput = {
  AND?: Prisma.ResponseScalarWhereInput | Prisma.ResponseScalarWhereInput[];
  OR?: Prisma.ResponseScalarWhereInput[];
  NOT?: Prisma.ResponseScalarWhereInput | Prisma.ResponseScalarWhereInput[];
  id?: Prisma.StringFilter<"Response"> | string;
  createdAt?: Prisma.DateTimeFilter<"Response"> | Date | string;
  updatedAt?: Prisma.DateTimeFilter<"Response"> | Date | string;
  finished?: Prisma.BoolFilter<"Response"> | boolean;
  surveyId?: Prisma.StringFilter<"Response"> | string;
  contactId?: Prisma.StringNullableFilter<"Response"> | string | null;
  endingId?: Prisma.StringNullableFilter<"Response"> | string | null;
  data?: Prisma.JsonFilter<"Response">;
  variables?: Prisma.JsonFilter<"Response">;
  ttc?: Prisma.JsonFilter<"Response">;
  meta?: Prisma.JsonFilter<"Response">;
  contactAttributes?: Prisma.JsonNullableFilter<"Response">;
  singleUseId?: Prisma.StringNullableFilter<"Response"> | string | null;
  language?: Prisma.StringNullableFilter<"Response"> | string | null;
  displayId?: Prisma.StringNullableFilter<"Response"> | string | null;
};

export type ResponseCreateWithoutTagsInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  survey: Prisma.SurveyCreateNestedOneWithoutResponsesInput;
  contact?: Prisma.ContactCreateNestedOneWithoutResponsesInput;
  quotaLinks?: Prisma.ResponseQuotaLinkCreateNestedManyWithoutResponseInput;
  display?: Prisma.DisplayCreateNestedOneWithoutResponseInput;
};

export type ResponseUncheckedCreateWithoutTagsInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  surveyId: string;
  contactId?: string | null;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  displayId?: string | null;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedCreateNestedManyWithoutResponseInput;
};

export type ResponseCreateOrConnectWithoutTagsInput = {
  where: Prisma.ResponseWhereUniqueInput;
  create: Prisma.XOR<Prisma.ResponseCreateWithoutTagsInput, Prisma.ResponseUncheckedCreateWithoutTagsInput>;
};

export type ResponseUpsertWithoutTagsInput = {
  update: Prisma.XOR<Prisma.ResponseUpdateWithoutTagsInput, Prisma.ResponseUncheckedUpdateWithoutTagsInput>;
  create: Prisma.XOR<Prisma.ResponseCreateWithoutTagsInput, Prisma.ResponseUncheckedCreateWithoutTagsInput>;
  where?: Prisma.ResponseWhereInput;
};

export type ResponseUpdateToOneWithWhereWithoutTagsInput = {
  where?: Prisma.ResponseWhereInput;
  data: Prisma.XOR<Prisma.ResponseUpdateWithoutTagsInput, Prisma.ResponseUncheckedUpdateWithoutTagsInput>;
};

export type ResponseUpdateWithoutTagsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  survey?: Prisma.SurveyUpdateOneRequiredWithoutResponsesNestedInput;
  contact?: Prisma.ContactUpdateOneWithoutResponsesNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUpdateManyWithoutResponseNestedInput;
  display?: Prisma.DisplayUpdateOneWithoutResponseNestedInput;
};

export type ResponseUncheckedUpdateWithoutTagsInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  surveyId?: Prisma.StringFieldUpdateOperationsInput | string;
  contactId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  displayId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedUpdateManyWithoutResponseNestedInput;
};

export type ResponseCreateWithoutDisplayInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  survey: Prisma.SurveyCreateNestedOneWithoutResponsesInput;
  contact?: Prisma.ContactCreateNestedOneWithoutResponsesInput;
  tags?: Prisma.TagsOnResponsesCreateNestedManyWithoutResponseInput;
  quotaLinks?: Prisma.ResponseQuotaLinkCreateNestedManyWithoutResponseInput;
};

export type ResponseUncheckedCreateWithoutDisplayInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  surveyId: string;
  contactId?: string | null;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  tags?: Prisma.TagsOnResponsesUncheckedCreateNestedManyWithoutResponseInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedCreateNestedManyWithoutResponseInput;
};

export type ResponseCreateOrConnectWithoutDisplayInput = {
  where: Prisma.ResponseWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ResponseCreateWithoutDisplayInput,
    Prisma.ResponseUncheckedCreateWithoutDisplayInput
  >;
};

export type ResponseUpsertWithoutDisplayInput = {
  update: Prisma.XOR<
    Prisma.ResponseUpdateWithoutDisplayInput,
    Prisma.ResponseUncheckedUpdateWithoutDisplayInput
  >;
  create: Prisma.XOR<
    Prisma.ResponseCreateWithoutDisplayInput,
    Prisma.ResponseUncheckedCreateWithoutDisplayInput
  >;
  where?: Prisma.ResponseWhereInput;
};

export type ResponseUpdateToOneWithWhereWithoutDisplayInput = {
  where?: Prisma.ResponseWhereInput;
  data: Prisma.XOR<
    Prisma.ResponseUpdateWithoutDisplayInput,
    Prisma.ResponseUncheckedUpdateWithoutDisplayInput
  >;
};

export type ResponseUpdateWithoutDisplayInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  survey?: Prisma.SurveyUpdateOneRequiredWithoutResponsesNestedInput;
  contact?: Prisma.ContactUpdateOneWithoutResponsesNestedInput;
  tags?: Prisma.TagsOnResponsesUpdateManyWithoutResponseNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUpdateManyWithoutResponseNestedInput;
};

export type ResponseUncheckedUpdateWithoutDisplayInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  surveyId?: Prisma.StringFieldUpdateOperationsInput | string;
  contactId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  tags?: Prisma.TagsOnResponsesUncheckedUpdateManyWithoutResponseNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedUpdateManyWithoutResponseNestedInput;
};

export type ResponseCreateWithoutSurveyInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  contact?: Prisma.ContactCreateNestedOneWithoutResponsesInput;
  tags?: Prisma.TagsOnResponsesCreateNestedManyWithoutResponseInput;
  quotaLinks?: Prisma.ResponseQuotaLinkCreateNestedManyWithoutResponseInput;
  display?: Prisma.DisplayCreateNestedOneWithoutResponseInput;
};

export type ResponseUncheckedCreateWithoutSurveyInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  contactId?: string | null;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  displayId?: string | null;
  tags?: Prisma.TagsOnResponsesUncheckedCreateNestedManyWithoutResponseInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedCreateNestedManyWithoutResponseInput;
};

export type ResponseCreateOrConnectWithoutSurveyInput = {
  where: Prisma.ResponseWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ResponseCreateWithoutSurveyInput,
    Prisma.ResponseUncheckedCreateWithoutSurveyInput
  >;
};

export type ResponseCreateManySurveyInputEnvelope = {
  data: Prisma.ResponseCreateManySurveyInput | Prisma.ResponseCreateManySurveyInput[];
  skipDuplicates?: boolean;
};

export type ResponseUpsertWithWhereUniqueWithoutSurveyInput = {
  where: Prisma.ResponseWhereUniqueInput;
  update: Prisma.XOR<
    Prisma.ResponseUpdateWithoutSurveyInput,
    Prisma.ResponseUncheckedUpdateWithoutSurveyInput
  >;
  create: Prisma.XOR<
    Prisma.ResponseCreateWithoutSurveyInput,
    Prisma.ResponseUncheckedCreateWithoutSurveyInput
  >;
};

export type ResponseUpdateWithWhereUniqueWithoutSurveyInput = {
  where: Prisma.ResponseWhereUniqueInput;
  data: Prisma.XOR<Prisma.ResponseUpdateWithoutSurveyInput, Prisma.ResponseUncheckedUpdateWithoutSurveyInput>;
};

export type ResponseUpdateManyWithWhereWithoutSurveyInput = {
  where: Prisma.ResponseScalarWhereInput;
  data: Prisma.XOR<
    Prisma.ResponseUpdateManyMutationInput,
    Prisma.ResponseUncheckedUpdateManyWithoutSurveyInput
  >;
};

export type ResponseCreateWithoutQuotaLinksInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  survey: Prisma.SurveyCreateNestedOneWithoutResponsesInput;
  contact?: Prisma.ContactCreateNestedOneWithoutResponsesInput;
  tags?: Prisma.TagsOnResponsesCreateNestedManyWithoutResponseInput;
  display?: Prisma.DisplayCreateNestedOneWithoutResponseInput;
};

export type ResponseUncheckedCreateWithoutQuotaLinksInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  surveyId: string;
  contactId?: string | null;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  displayId?: string | null;
  tags?: Prisma.TagsOnResponsesUncheckedCreateNestedManyWithoutResponseInput;
};

export type ResponseCreateOrConnectWithoutQuotaLinksInput = {
  where: Prisma.ResponseWhereUniqueInput;
  create: Prisma.XOR<
    Prisma.ResponseCreateWithoutQuotaLinksInput,
    Prisma.ResponseUncheckedCreateWithoutQuotaLinksInput
  >;
};

export type ResponseUpsertWithoutQuotaLinksInput = {
  update: Prisma.XOR<
    Prisma.ResponseUpdateWithoutQuotaLinksInput,
    Prisma.ResponseUncheckedUpdateWithoutQuotaLinksInput
  >;
  create: Prisma.XOR<
    Prisma.ResponseCreateWithoutQuotaLinksInput,
    Prisma.ResponseUncheckedCreateWithoutQuotaLinksInput
  >;
  where?: Prisma.ResponseWhereInput;
};

export type ResponseUpdateToOneWithWhereWithoutQuotaLinksInput = {
  where?: Prisma.ResponseWhereInput;
  data: Prisma.XOR<
    Prisma.ResponseUpdateWithoutQuotaLinksInput,
    Prisma.ResponseUncheckedUpdateWithoutQuotaLinksInput
  >;
};

export type ResponseUpdateWithoutQuotaLinksInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  survey?: Prisma.SurveyUpdateOneRequiredWithoutResponsesNestedInput;
  contact?: Prisma.ContactUpdateOneWithoutResponsesNestedInput;
  tags?: Prisma.TagsOnResponsesUpdateManyWithoutResponseNestedInput;
  display?: Prisma.DisplayUpdateOneWithoutResponseNestedInput;
};

export type ResponseUncheckedUpdateWithoutQuotaLinksInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  surveyId?: Prisma.StringFieldUpdateOperationsInput | string;
  contactId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  displayId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  tags?: Prisma.TagsOnResponsesUncheckedUpdateManyWithoutResponseNestedInput;
};

export type ResponseCreateManyContactInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  surveyId: string;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  displayId?: string | null;
};

export type ResponseUpdateWithoutContactInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  survey?: Prisma.SurveyUpdateOneRequiredWithoutResponsesNestedInput;
  tags?: Prisma.TagsOnResponsesUpdateManyWithoutResponseNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUpdateManyWithoutResponseNestedInput;
  display?: Prisma.DisplayUpdateOneWithoutResponseNestedInput;
};

export type ResponseUncheckedUpdateWithoutContactInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  surveyId?: Prisma.StringFieldUpdateOperationsInput | string;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  displayId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  tags?: Prisma.TagsOnResponsesUncheckedUpdateManyWithoutResponseNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedUpdateManyWithoutResponseNestedInput;
};

export type ResponseUncheckedUpdateManyWithoutContactInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  surveyId?: Prisma.StringFieldUpdateOperationsInput | string;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
  variables?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
  ttc?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
  meta?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
  contactAttributes?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  displayId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

export type ResponseCreateManySurveyInput = {
  id?: string;
  createdAt?: Date | string;
  updatedAt?: Date | string;
  finished?: boolean;
  contactId?: string | null;
  endingId?: string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: string | null;
  language?: string | null;
  displayId?: string | null;
};

export type ResponseUpdateWithoutSurveyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  contact?: Prisma.ContactUpdateOneWithoutResponsesNestedInput;
  tags?: Prisma.TagsOnResponsesUpdateManyWithoutResponseNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUpdateManyWithoutResponseNestedInput;
  display?: Prisma.DisplayUpdateOneWithoutResponseNestedInput;
};

export type ResponseUncheckedUpdateWithoutSurveyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  contactId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: PrismaJson.ResponseData;
  variables?: PrismaJson.ResponseVariables;
  ttc?: PrismaJson.ResponseTtc;
  meta?: PrismaJson.ResponseMeta;
  contactAttributes?: PrismaJson.ResponseContactAttributes | Prisma.NullableJsonNullValueInput;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  displayId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  tags?: Prisma.TagsOnResponsesUncheckedUpdateManyWithoutResponseNestedInput;
  quotaLinks?: Prisma.ResponseQuotaLinkUncheckedUpdateManyWithoutResponseNestedInput;
};

export type ResponseUncheckedUpdateManyWithoutSurveyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string;
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
  finished?: Prisma.BoolFieldUpdateOperationsInput | boolean;
  contactId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  endingId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  data?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
  variables?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
  ttc?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
  meta?: Prisma.JsonNullValueInput | runtime.InputJsonValue;
  contactAttributes?: Prisma.NullableJsonNullValueInput | runtime.InputJsonValue;
  singleUseId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  language?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
  displayId?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
};

/**
 * Count Type ResponseCountOutputType
 */

export type ResponseCountOutputType = {
  tags: number;
  quotaLinks: number;
};

export type ResponseCountOutputTypeSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  tags?: boolean | ResponseCountOutputTypeCountTagsArgs;
  quotaLinks?: boolean | ResponseCountOutputTypeCountQuotaLinksArgs;
};

/**
 * ResponseCountOutputType without action
 */
export type ResponseCountOutputTypeDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ResponseCountOutputType
   */
  select?: Prisma.ResponseCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * ResponseCountOutputType without action
 */
export type ResponseCountOutputTypeCountTagsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.TagsOnResponsesWhereInput;
};

/**
 * ResponseCountOutputType without action
 */
export type ResponseCountOutputTypeCountQuotaLinksArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  where?: Prisma.ResponseQuotaLinkWhereInput;
};

export type ResponseSelect<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    finished?: boolean;
    surveyId?: boolean;
    contactId?: boolean;
    endingId?: boolean;
    data?: boolean;
    variables?: boolean;
    ttc?: boolean;
    meta?: boolean;
    contactAttributes?: boolean;
    singleUseId?: boolean;
    language?: boolean;
    displayId?: boolean;
    survey?: boolean | Prisma.SurveyDefaultArgs<ExtArgs>;
    contact?: boolean | Prisma.Response$contactArgs<ExtArgs>;
    tags?: boolean | Prisma.Response$tagsArgs<ExtArgs>;
    quotaLinks?: boolean | Prisma.Response$quotaLinksArgs<ExtArgs>;
    display?: boolean | Prisma.Response$displayArgs<ExtArgs>;
    _count?: boolean | Prisma.ResponseCountOutputTypeDefaultArgs<ExtArgs>;
  },
  ExtArgs["result"]["response"]
>;

export type ResponseSelectCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    finished?: boolean;
    surveyId?: boolean;
    contactId?: boolean;
    endingId?: boolean;
    data?: boolean;
    variables?: boolean;
    ttc?: boolean;
    meta?: boolean;
    contactAttributes?: boolean;
    singleUseId?: boolean;
    language?: boolean;
    displayId?: boolean;
    survey?: boolean | Prisma.SurveyDefaultArgs<ExtArgs>;
    contact?: boolean | Prisma.Response$contactArgs<ExtArgs>;
    display?: boolean | Prisma.Response$displayArgs<ExtArgs>;
  },
  ExtArgs["result"]["response"]
>;

export type ResponseSelectUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
  {
    id?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    finished?: boolean;
    surveyId?: boolean;
    contactId?: boolean;
    endingId?: boolean;
    data?: boolean;
    variables?: boolean;
    ttc?: boolean;
    meta?: boolean;
    contactAttributes?: boolean;
    singleUseId?: boolean;
    language?: boolean;
    displayId?: boolean;
    survey?: boolean | Prisma.SurveyDefaultArgs<ExtArgs>;
    contact?: boolean | Prisma.Response$contactArgs<ExtArgs>;
    display?: boolean | Prisma.Response$displayArgs<ExtArgs>;
  },
  ExtArgs["result"]["response"]
>;

export type ResponseSelectScalar = {
  id?: boolean;
  createdAt?: boolean;
  updatedAt?: boolean;
  finished?: boolean;
  surveyId?: boolean;
  contactId?: boolean;
  endingId?: boolean;
  data?: boolean;
  variables?: boolean;
  ttc?: boolean;
  meta?: boolean;
  contactAttributes?: boolean;
  singleUseId?: boolean;
  language?: boolean;
  displayId?: boolean;
};

export type ResponseOmit<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
  | "id"
  | "createdAt"
  | "updatedAt"
  | "finished"
  | "surveyId"
  | "contactId"
  | "endingId"
  | "data"
  | "variables"
  | "ttc"
  | "meta"
  | "contactAttributes"
  | "singleUseId"
  | "language"
  | "displayId",
  ExtArgs["result"]["response"]
>;
export type ResponseInclude<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  survey?: boolean | Prisma.SurveyDefaultArgs<ExtArgs>;
  contact?: boolean | Prisma.Response$contactArgs<ExtArgs>;
  tags?: boolean | Prisma.Response$tagsArgs<ExtArgs>;
  quotaLinks?: boolean | Prisma.Response$quotaLinksArgs<ExtArgs>;
  display?: boolean | Prisma.Response$displayArgs<ExtArgs>;
  _count?: boolean | Prisma.ResponseCountOutputTypeDefaultArgs<ExtArgs>;
};
export type ResponseIncludeCreateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  survey?: boolean | Prisma.SurveyDefaultArgs<ExtArgs>;
  contact?: boolean | Prisma.Response$contactArgs<ExtArgs>;
  display?: boolean | Prisma.Response$displayArgs<ExtArgs>;
};
export type ResponseIncludeUpdateManyAndReturn<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  survey?: boolean | Prisma.SurveyDefaultArgs<ExtArgs>;
  contact?: boolean | Prisma.Response$contactArgs<ExtArgs>;
  display?: boolean | Prisma.Response$displayArgs<ExtArgs>;
};

export type $ResponsePayload<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  name: "Response";
  objects: {
    survey: Prisma.$SurveyPayload<ExtArgs>;
    contact: Prisma.$ContactPayload<ExtArgs> | null;
    tags: Prisma.$TagsOnResponsesPayload<ExtArgs>[];
    quotaLinks: Prisma.$ResponseQuotaLinkPayload<ExtArgs>[];
    display: Prisma.$DisplayPayload<ExtArgs> | null;
  };
  scalars: runtime.Types.Extensions.GetPayloadResult<
    {
      id: string;
      createdAt: Date;
      updatedAt: Date;
      finished: boolean;
      surveyId: string;
      contactId: string | null;
      endingId: string | null;
      /**
       * [ResponseData]
       */
      data: PrismaJson.ResponseData;
      /**
       * [ResponseVariables]
       */
      variables: PrismaJson.ResponseVariables;
      /**
       * [ResponseTtc]
       */
      ttc: PrismaJson.ResponseTtc;
      /**
       * [ResponseMeta]
       */
      meta: PrismaJson.ResponseMeta;
      /**
       * [ResponseContactAttributes]
       */
      contactAttributes: PrismaJson.ResponseContactAttributes | null;
      singleUseId: string | null;
      language: string | null;
      displayId: string | null;
    },
    ExtArgs["result"]["response"]
  >;
  composites: {};
};

export type ResponseGetPayload<S extends boolean | null | undefined | ResponseDefaultArgs> =
  runtime.Types.Result.GetResult<Prisma.$ResponsePayload, S>;

export type ResponseCountArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<ResponseFindManyArgs, "select" | "include" | "distinct" | "omit"> & {
  select?: ResponseCountAggregateInputType | true;
};

export interface ResponseDelegate<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>["model"]["Response"]; meta: { name: "Response" } };
  /**
   * Find zero or one Response that matches the filter.
   * @param {ResponseFindUniqueArgs} args - Arguments to find a Response
   * @example
   * // Get one Response
   * const response = await prisma.response.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends ResponseFindUniqueArgs>(
    args: Prisma.SelectSubset<T, ResponseFindUniqueArgs<ExtArgs>>
  ): Prisma.Prisma__ResponseClient<
    runtime.Types.Result.GetResult<
      Prisma.$ResponsePayload<ExtArgs>,
      T,
      "findUnique",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find one Response that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {ResponseFindUniqueOrThrowArgs} args - Arguments to find a Response
   * @example
   * // Get one Response
   * const response = await prisma.response.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends ResponseFindUniqueOrThrowArgs>(
    args: Prisma.SelectSubset<T, ResponseFindUniqueOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__ResponseClient<
    runtime.Types.Result.GetResult<
      Prisma.$ResponsePayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Response that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ResponseFindFirstArgs} args - Arguments to find a Response
   * @example
   * // Get one Response
   * const response = await prisma.response.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends ResponseFindFirstArgs>(
    args?: Prisma.SelectSubset<T, ResponseFindFirstArgs<ExtArgs>>
  ): Prisma.Prisma__ResponseClient<
    runtime.Types.Result.GetResult<
      Prisma.$ResponsePayload<ExtArgs>,
      T,
      "findFirst",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find the first Response that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ResponseFindFirstOrThrowArgs} args - Arguments to find a Response
   * @example
   * // Get one Response
   * const response = await prisma.response.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends ResponseFindFirstOrThrowArgs>(
    args?: Prisma.SelectSubset<T, ResponseFindFirstOrThrowArgs<ExtArgs>>
  ): Prisma.Prisma__ResponseClient<
    runtime.Types.Result.GetResult<
      Prisma.$ResponsePayload<ExtArgs>,
      T,
      "findFirstOrThrow",
      GlobalOmitOptions
    >,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Find zero or more Responses that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ResponseFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Responses
   * const responses = await prisma.response.findMany()
   *
   * // Get first 10 Responses
   * const responses = await prisma.response.findMany({ take: 10 })
   *
   * // Only select the `id`
   * const responseWithIdOnly = await prisma.response.findMany({ select: { id: true } })
   *
   */
  findMany<T extends ResponseFindManyArgs>(
    args?: Prisma.SelectSubset<T, ResponseFindManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>
  >;

  /**
   * Create a Response.
   * @param {ResponseCreateArgs} args - Arguments to create a Response.
   * @example
   * // Create one Response
   * const Response = await prisma.response.create({
   *   data: {
   *     // ... data to create a Response
   *   }
   * })
   *
   */
  create<T extends ResponseCreateArgs>(
    args: Prisma.SelectSubset<T, ResponseCreateArgs<ExtArgs>>
  ): Prisma.Prisma__ResponseClient<
    runtime.Types.Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Create many Responses.
   * @param {ResponseCreateManyArgs} args - Arguments to create many Responses.
   * @example
   * // Create many Responses
   * const response = await prisma.response.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   */
  createMany<T extends ResponseCreateManyArgs>(
    args?: Prisma.SelectSubset<T, ResponseCreateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Create many Responses and returns the data saved in the database.
   * @param {ResponseCreateManyAndReturnArgs} args - Arguments to create many Responses.
   * @example
   * // Create many Responses
   * const response = await prisma.response.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Create many Responses and only return the `id`
   * const responseWithIdOnly = await prisma.response.createManyAndReturn({
   *   select: { id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  createManyAndReturn<T extends ResponseCreateManyAndReturnArgs>(
    args?: Prisma.SelectSubset<T, ResponseCreateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$ResponsePayload<ExtArgs>,
      T,
      "createManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Delete a Response.
   * @param {ResponseDeleteArgs} args - Arguments to delete one Response.
   * @example
   * // Delete one Response
   * const Response = await prisma.response.delete({
   *   where: {
   *     // ... filter to delete one Response
   *   }
   * })
   *
   */
  delete<T extends ResponseDeleteArgs>(
    args: Prisma.SelectSubset<T, ResponseDeleteArgs<ExtArgs>>
  ): Prisma.Prisma__ResponseClient<
    runtime.Types.Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Update one Response.
   * @param {ResponseUpdateArgs} args - Arguments to update one Response.
   * @example
   * // Update one Response
   * const response = await prisma.response.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  update<T extends ResponseUpdateArgs>(
    args: Prisma.SelectSubset<T, ResponseUpdateArgs<ExtArgs>>
  ): Prisma.Prisma__ResponseClient<
    runtime.Types.Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Delete zero or more Responses.
   * @param {ResponseDeleteManyArgs} args - Arguments to filter Responses to delete.
   * @example
   * // Delete a few Responses
   * const { count } = await prisma.response.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   *
   */
  deleteMany<T extends ResponseDeleteManyArgs>(
    args?: Prisma.SelectSubset<T, ResponseDeleteManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Responses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ResponseUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Responses
   * const response = await prisma.response.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   *
   */
  updateMany<T extends ResponseUpdateManyArgs>(
    args: Prisma.SelectSubset<T, ResponseUpdateManyArgs<ExtArgs>>
  ): Prisma.PrismaPromise<Prisma.BatchPayload>;

  /**
   * Update zero or more Responses and returns the data updated in the database.
   * @param {ResponseUpdateManyAndReturnArgs} args - Arguments to update many Responses.
   * @example
   * // Update many Responses
   * const response = await prisma.response.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *
   * // Update zero or more Responses and only return the `id`
   * const responseWithIdOnly = await prisma.response.updateManyAndReturn({
   *   select: { id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   *
   */
  updateManyAndReturn<T extends ResponseUpdateManyAndReturnArgs>(
    args: Prisma.SelectSubset<T, ResponseUpdateManyAndReturnArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    runtime.Types.Result.GetResult<
      Prisma.$ResponsePayload<ExtArgs>,
      T,
      "updateManyAndReturn",
      GlobalOmitOptions
    >
  >;

  /**
   * Create or update one Response.
   * @param {ResponseUpsertArgs} args - Arguments to update or create a Response.
   * @example
   * // Update or create a Response
   * const response = await prisma.response.upsert({
   *   create: {
   *     // ... data to create a Response
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Response we want to update
   *   }
   * })
   */
  upsert<T extends ResponseUpsertArgs>(
    args: Prisma.SelectSubset<T, ResponseUpsertArgs<ExtArgs>>
  ): Prisma.Prisma__ResponseClient<
    runtime.Types.Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>,
    never,
    ExtArgs,
    GlobalOmitOptions
  >;

  /**
   * Count the number of Responses.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ResponseCountArgs} args - Arguments to filter Responses to count.
   * @example
   * // Count the number of Responses
   * const count = await prisma.response.count({
   *   where: {
   *     // ... the filter for the Responses we want to count
   *   }
   * })
   **/
  count<T extends ResponseCountArgs>(
    args?: Prisma.Subset<T, ResponseCountArgs>
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<"select", any>
      ? T["select"] extends true
        ? number
        : Prisma.GetScalarType<T["select"], ResponseCountAggregateOutputType>
      : number
  >;

  /**
   * Allows you to perform aggregations operations on a Response.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
   **/
  aggregate<T extends ResponseAggregateArgs>(
    args: Prisma.Subset<T, ResponseAggregateArgs>
  ): Prisma.PrismaPromise<GetResponseAggregateType<T>>;

  /**
   * Group by Response.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {ResponseGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   *
   **/
  groupBy<
    T extends ResponseGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<"skip", Prisma.Keys<T>>,
      Prisma.Extends<"take", Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: ResponseGroupByArgs["orderBy"] }
      : { orderBy?: ResponseGroupByArgs["orderBy"] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T["orderBy"]>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T["by"]>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T["having"]>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T["by"] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
      ? `Error: "by" must not be empty.`
      : HavingValid extends Prisma.False
        ? {
            [P in HavingFields]: P extends ByFields
              ? never
              : P extends string
                ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                : [Error, "Field ", P, ` in "having" needs to be provided in "by"`];
          }[HavingFields]
        : "take" extends Prisma.Keys<T>
          ? "orderBy" extends Prisma.Keys<T>
            ? ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields]
            : 'Error: If you provide "take", you also need to provide "orderBy"'
          : "skip" extends Prisma.Keys<T>
            ? "orderBy" extends Prisma.Keys<T>
              ? ByValid extends Prisma.True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "skip", you also need to provide "orderBy"'
            : ByValid extends Prisma.True
              ? {}
              : {
                  [P in OrderFields]: P extends ByFields
                    ? never
                    : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                }[OrderFields],
  >(
    args: Prisma.SubsetIntersection<T, ResponseGroupByArgs, OrderByArg> & InputErrors
  ): {} extends InputErrors ? GetResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
  /**
   * Fields of the Response model
   */
  readonly fields: ResponseFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Response.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__ResponseClient<
  T,
  Null = never,
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
  GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise";
  survey<T extends Prisma.SurveyDefaultArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.SurveyDefaultArgs<ExtArgs>>
  ): Prisma.Prisma__SurveyClient<
    | runtime.Types.Result.GetResult<
        Prisma.$SurveyPayload<ExtArgs>,
        T,
        "findUniqueOrThrow",
        GlobalOmitOptions
      >
    | Null,
    Null,
    ExtArgs,
    GlobalOmitOptions
  >;
  contact<T extends Prisma.Response$contactArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Response$contactArgs<ExtArgs>>
  ): Prisma.Prisma__ContactClient<
    runtime.Types.Result.GetResult<
      Prisma.$ContactPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  tags<T extends Prisma.Response$tagsArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Response$tagsArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$TagsOnResponsesPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  quotaLinks<T extends Prisma.Response$quotaLinksArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Response$quotaLinksArgs<ExtArgs>>
  ): Prisma.PrismaPromise<
    | runtime.Types.Result.GetResult<
        Prisma.$ResponseQuotaLinkPayload<ExtArgs>,
        T,
        "findMany",
        GlobalOmitOptions
      >
    | Null
  >;
  display<T extends Prisma.Response$displayArgs<ExtArgs> = {}>(
    args?: Prisma.Subset<T, Prisma.Response$displayArgs<ExtArgs>>
  ): Prisma.Prisma__DisplayClient<
    runtime.Types.Result.GetResult<
      Prisma.$DisplayPayload<ExtArgs>,
      T,
      "findUniqueOrThrow",
      GlobalOmitOptions
    > | null,
    null,
    ExtArgs,
    GlobalOmitOptions
  >;
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(
    onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
  ): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(
    onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
  ): runtime.Types.Utils.JsPromise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Response model
 */
export interface ResponseFieldRefs {
  readonly id: Prisma.FieldRef<"Response", "String">;
  readonly createdAt: Prisma.FieldRef<"Response", "DateTime">;
  readonly updatedAt: Prisma.FieldRef<"Response", "DateTime">;
  readonly finished: Prisma.FieldRef<"Response", "Boolean">;
  readonly surveyId: Prisma.FieldRef<"Response", "String">;
  readonly contactId: Prisma.FieldRef<"Response", "String">;
  readonly endingId: Prisma.FieldRef<"Response", "String">;
  readonly data: Prisma.FieldRef<"Response", "Json">;
  readonly variables: Prisma.FieldRef<"Response", "Json">;
  readonly ttc: Prisma.FieldRef<"Response", "Json">;
  readonly meta: Prisma.FieldRef<"Response", "Json">;
  readonly contactAttributes: Prisma.FieldRef<"Response", "Json">;
  readonly singleUseId: Prisma.FieldRef<"Response", "String">;
  readonly language: Prisma.FieldRef<"Response", "String">;
  readonly displayId: Prisma.FieldRef<"Response", "String">;
}

// Custom InputTypes
/**
 * Response findUnique
 */
export type ResponseFindUniqueArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * Filter, which Response to fetch.
   */
  where: Prisma.ResponseWhereUniqueInput;
};

/**
 * Response findUniqueOrThrow
 */
export type ResponseFindUniqueOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * Filter, which Response to fetch.
   */
  where: Prisma.ResponseWhereUniqueInput;
};

/**
 * Response findFirst
 */
export type ResponseFindFirstArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * Filter, which Response to fetch.
   */
  where?: Prisma.ResponseWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Responses to fetch.
   */
  orderBy?: Prisma.ResponseOrderByWithRelationInput | Prisma.ResponseOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Responses.
   */
  cursor?: Prisma.ResponseWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Responses from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Responses.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Responses.
   */
  distinct?: Prisma.ResponseScalarFieldEnum | Prisma.ResponseScalarFieldEnum[];
};

/**
 * Response findFirstOrThrow
 */
export type ResponseFindFirstOrThrowArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * Filter, which Response to fetch.
   */
  where?: Prisma.ResponseWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Responses to fetch.
   */
  orderBy?: Prisma.ResponseOrderByWithRelationInput | Prisma.ResponseOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for searching for Responses.
   */
  cursor?: Prisma.ResponseWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Responses from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Responses.
   */
  skip?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   *
   * Filter by unique combinations of Responses.
   */
  distinct?: Prisma.ResponseScalarFieldEnum | Prisma.ResponseScalarFieldEnum[];
};

/**
 * Response findMany
 */
export type ResponseFindManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * Filter, which Responses to fetch.
   */
  where?: Prisma.ResponseWhereInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   *
   * Determine the order of Responses to fetch.
   */
  orderBy?: Prisma.ResponseOrderByWithRelationInput | Prisma.ResponseOrderByWithRelationInput[];
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   *
   * Sets the position for listing Responses.
   */
  cursor?: Prisma.ResponseWhereUniqueInput;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Take `Â±n` Responses from the position of the cursor.
   */
  take?: number;
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   *
   * Skip the first `n` Responses.
   */
  skip?: number;
  distinct?: Prisma.ResponseScalarFieldEnum | Prisma.ResponseScalarFieldEnum[];
};

/**
 * Response create
 */
export type ResponseCreateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * The data needed to create a Response.
   */
  data: Prisma.XOR<Prisma.ResponseCreateInput, Prisma.ResponseUncheckedCreateInput>;
};

/**
 * Response createMany
 */
export type ResponseCreateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to create many Responses.
   */
  data: Prisma.ResponseCreateManyInput | Prisma.ResponseCreateManyInput[];
  skipDuplicates?: boolean;
};

/**
 * Response createManyAndReturn
 */
export type ResponseCreateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelectCreateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * The data used to create many Responses.
   */
  data: Prisma.ResponseCreateManyInput | Prisma.ResponseCreateManyInput[];
  skipDuplicates?: boolean;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Response update
 */
export type ResponseUpdateArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * The data needed to update a Response.
   */
  data: Prisma.XOR<Prisma.ResponseUpdateInput, Prisma.ResponseUncheckedUpdateInput>;
  /**
   * Choose, which Response to update.
   */
  where: Prisma.ResponseWhereUniqueInput;
};

/**
 * Response updateMany
 */
export type ResponseUpdateManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * The data used to update Responses.
   */
  data: Prisma.XOR<Prisma.ResponseUpdateManyMutationInput, Prisma.ResponseUncheckedUpdateManyInput>;
  /**
   * Filter which Responses to update
   */
  where?: Prisma.ResponseWhereInput;
  /**
   * Limit how many Responses to update.
   */
  limit?: number;
};

/**
 * Response updateManyAndReturn
 */
export type ResponseUpdateManyAndReturnArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelectUpdateManyAndReturn<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * The data used to update Responses.
   */
  data: Prisma.XOR<Prisma.ResponseUpdateManyMutationInput, Prisma.ResponseUncheckedUpdateManyInput>;
  /**
   * Filter which Responses to update
   */
  where?: Prisma.ResponseWhereInput;
  /**
   * Limit how many Responses to update.
   */
  limit?: number;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Response upsert
 */
export type ResponseUpsertArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * The filter to search for the Response to update in case it exists.
   */
  where: Prisma.ResponseWhereUniqueInput;
  /**
   * In case the Response found by the `where` argument doesn't exist, create a new Response with this data.
   */
  create: Prisma.XOR<Prisma.ResponseCreateInput, Prisma.ResponseUncheckedCreateInput>;
  /**
   * In case the Response was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.ResponseUpdateInput, Prisma.ResponseUncheckedUpdateInput>;
};

/**
 * Response delete
 */
export type ResponseDeleteArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
  /**
   * Filter which Response to delete.
   */
  where: Prisma.ResponseWhereUniqueInput;
};

/**
 * Response deleteMany
 */
export type ResponseDeleteManyArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Filter which Responses to delete
   */
  where?: Prisma.ResponseWhereInput;
  /**
   * Limit how many Responses to delete.
   */
  limit?: number;
};

/**
 * Response.contact
 */
export type Response$contactArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Contact
   */
  select?: Prisma.ContactSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Contact
   */
  omit?: Prisma.ContactOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ContactInclude<ExtArgs> | null;
  where?: Prisma.ContactWhereInput;
};

/**
 * Response.tags
 */
export type Response$tagsArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the TagsOnResponses
   */
  select?: Prisma.TagsOnResponsesSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the TagsOnResponses
   */
  omit?: Prisma.TagsOnResponsesOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.TagsOnResponsesInclude<ExtArgs> | null;
  where?: Prisma.TagsOnResponsesWhereInput;
  orderBy?: Prisma.TagsOnResponsesOrderByWithRelationInput | Prisma.TagsOnResponsesOrderByWithRelationInput[];
  cursor?: Prisma.TagsOnResponsesWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.TagsOnResponsesScalarFieldEnum | Prisma.TagsOnResponsesScalarFieldEnum[];
};

/**
 * Response.quotaLinks
 */
export type Response$quotaLinksArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the ResponseQuotaLink
   */
  select?: Prisma.ResponseQuotaLinkSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the ResponseQuotaLink
   */
  omit?: Prisma.ResponseQuotaLinkOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseQuotaLinkInclude<ExtArgs> | null;
  where?: Prisma.ResponseQuotaLinkWhereInput;
  orderBy?:
    | Prisma.ResponseQuotaLinkOrderByWithRelationInput
    | Prisma.ResponseQuotaLinkOrderByWithRelationInput[];
  cursor?: Prisma.ResponseQuotaLinkWhereUniqueInput;
  take?: number;
  skip?: number;
  distinct?: Prisma.ResponseQuotaLinkScalarFieldEnum | Prisma.ResponseQuotaLinkScalarFieldEnum[];
};

/**
 * Response.display
 */
export type Response$displayArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Display
   */
  select?: Prisma.DisplaySelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Display
   */
  omit?: Prisma.DisplayOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.DisplayInclude<ExtArgs> | null;
  where?: Prisma.DisplayWhereInput;
};

/**
 * Response without action
 */
export type ResponseDefaultArgs<
  ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
  /**
   * Select specific fields to fetch from the Response
   */
  select?: Prisma.ResponseSelect<ExtArgs> | null;
  /**
   * Omit specific fields from the Response
   */
  omit?: Prisma.ResponseOmit<ExtArgs> | null;
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.ResponseInclude<ExtArgs> | null;
};
