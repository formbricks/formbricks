---
title: Framework Usage Guidelines
icon: book
---

## Introduction

This document outlines the framework usage guidelines for Formbricks, which is built primarily on Next.js (with heavy use of Server-Side Rendering through the App Router), Tailwind CSS, Prisma ORM, and other related technologies. These guidelines ensure consistency, performance, and maintainability across all projects within the Formbricks ecosystem.

## Next.js Usage Guidelines

### App Router and Server Components

- Use the Next.js App Router with the /app directory for building the application.
- Leverage React Server Components, which are the default in the App Router.
- Perform server-side data fetching directly within page.tsx files using async function components.

### Data Fetching in page.tsx

- Implement data fetching logic directly in your page.tsx components. This allows for server-side rendering without needing separate data fetching methods like getServerSideProps.
- Utilize React Suspense and streaming features if using advanced asynchronous patterns.

### Server Actions for Mutations

- Define Server Actions in dedicated action.ts files.
- Server actions serve as entry points for mutations and delegate to service layers that perform Prisma operations and other business logic.
- This approach promotes separation of concerns and maintainability by keeping form actions and mutations decoupled from UI components.

### Error Handling and Performance

- Integrate error boundaries and loading states appropriately within your App Router structure.
- Optimize performance with Next.js built-in features such as dynamic imports, the Image component, and code splitting.

## Module Organization

### Feature-based Module Structure

- Organize code into feature-based modules under the `modules` directory, combining all related components, routes, and utilities.
- Each module should be self-contained and include all necessary files for the feature's functionality.

### Module Structure Example

A typical module structure follows this pattern:

```
modules/
  └── feature-name/
      ├── components/     # React components
      ├── lib/           # Business logic and utilities
      ├── types/         # TypeScript types
      ├── actions.ts     # Server actions
      └── route.ts       # API routes (if needed)
```

For example, the survey follow-ups module demonstrates this organization:

- Components for UI elements (`follow-up-modal.tsx`, `follow-up-item.tsx`)
- Utility functions in `lib/utils.ts`
- Type definitions specific to the feature
- Server actions for handling mutations
- All related files are grouped together for better maintainability

### Benefits of Module Organization

- **Encapsulation**: Each module contains all necessary code for a specific feature
- **Maintainability**: Related code is co-located, making it easier to understand and modify
- **Scalability**: New features can be added as separate modules without affecting existing code
- **Reusability**: Modules can be shared across different parts of the application

### Best Practices

1. Keep modules focused on a single feature or related set of features
2. Use clear, consistent naming conventions for module directories and files
3. Share common utilities through a shared library when needed across modules
4. Maintain separation of concerns within each module (UI, business logic, data access)

## Tailwind CSS Guidelines

### Setup and Configuration

- Start with the default Tailwind configuration and extend it as needed.
- Organize CSS by grouping utility classes and creating reusable component styles.
- Ensure that custom styles are scoped appropriately to prevent naming collisions.

### Best Practices

- Use utility classes extensively rather than writing custom CSS from scratch.
- Leverage responsive design utilities to manage different screen sizes.
- Maintain a component library for common UI elements to promote consistency across the app.

## Prisma and Database Access Guidelines

### Schema Management

- Clearly define and document the Prisma schema for your database models and relationships.
- Organize models logically and use proper naming conventions for clarity.
- Use Prisma migrations for managing schema changes over time.

### Query Best Practices

- Write efficient queries by selecting only the fields necessary for each operation.
- Utilize prepared queries and proper indexing to improve query performance.
- Implement proper error handling and transaction management to ensure consistent data state.

## Additional Technologies and Integrations

### Library and Dependency Management

- Follow best practices when integrating third-party libraries.
- Keep all dependencies up-to-date to benefit from the latest features and security patches.
- Document any custom integrations or configurations to ensure continuity in development.

## Conclusion

Adherence to these guidelines helps maintain a robust, scalable, and maintainable codebase across the Formbricks projects. For further details and updates, please consult additional documentation or contact the development team.
