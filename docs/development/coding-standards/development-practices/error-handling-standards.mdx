---
title: "Error Handling Standards"
description: "Standards for handling and reporting errors in the Formbricks codebase"
icon: circle-exclamation
---

## Error Types

### Custom Error Classes

```typescript
class SurveyError extends Error {
  constructor(
    message: string,
    public code: string
  ) {
    super(message);
    this.name = "SurveyError";
  }
}
```

### Error Codes

Define consistent error codes for different types of errors:

```typescript
export const ErrorCodes = {
  SURVEY_NOT_FOUND: "SURVEY_NOT_FOUND",
  INVALID_RESPONSE: "INVALID_RESPONSE",
  UNAUTHORIZED: "UNAUTHORIZED",
  // ...
} as const;
```

## Error Handling Patterns

### Async/Await

Use try-catch blocks with async/await:

```typescript
async function fetchSurvey(id: string) {
  try {
    const survey = await getSurvey(id);
    return survey;
  } catch (error) {
    if (error instanceof SurveyError) {
      // Handle known error types
      handleSurveyError(error);
    } else {
      // Handle unexpected errors
      reportError(error);
      throw error;
    }
  }
}
```

### Error Boundaries

Use React Error Boundaries for component-level error handling:

```typescript
class SurveyErrorBoundary extends React.Component {
  // Implementation
}
```

## Error Reporting

1. **User-Facing Errors**

   - Clear error messages
   - Actionable feedback
   - Appropriate UI handling

2. **Logging**

   - Structured error logs
   - Include context
   - Stack traces when needed

3. **Monitoring**
   - Error tracking
   - Performance monitoring
   - User impact analysis

## Best Practices

1. **Graceful Degradation**

   - Fail gracefully
   - Preserve user data
   - Clear recovery paths

2. **Security Considerations**

   - Sanitize error messages
   - Avoid exposing internals
   - Log securely

3. **Maintenance**
   - Regular error review
   - Update error handling
   - Improve based on patterns
